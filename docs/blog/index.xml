<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on </title>
    <link>/blog/index.xml</link>
    <description>Recent content in Blog on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Copyright © 2017 Shang</copyright>
    <lastBuildDate>Thu, 01 Sep 2016 20:56:28 +0000</lastBuildDate>
    <atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>windows安装caffe并编译fast-rcnn-demo</title>
      <link>blog/windows%E5%AE%89%E8%A3%85caffe%E5%B9%B6%E7%BC%96%E8%AF%91fast-rcnn-demo/</link>
      <pubDate>Thu, 01 Sep 2016 20:56:28 +0000</pubDate>
      
      <guid>blog/windows%E5%AE%89%E8%A3%85caffe%E5%B9%B6%E7%BC%96%E8%AF%91fast-rcnn-demo/</guid>
      <description>

&lt;h1 id=&#34;microsoft-caffe&#34;&gt;microsoft caffe&lt;/h1&gt;

&lt;p&gt;首先在微软github主页下载&lt;a href=&#34;https://github.com/microsoft/caffe&#34;&gt;microsoft-caffe&lt;/a&gt;，官方的编译运行文档写得比较详细，按照步骤来利用VS编译一般没什么问题。一般常见的问题是&lt;code&gt;error C2220: 警告被视为错误&lt;/code&gt;，只需&lt;strong&gt;右键项目，属性，C/C++，Treat Warnings as Error设置为No&lt;/strong&gt;即可。附上个人的&lt;a href=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/CommonSettings.props&#34;&gt;CommonSettings.props&lt;/a&gt;，仅供参考。&lt;/p&gt;

&lt;p&gt;所有项目编译成功之后，将&lt;code&gt;caffe_root\Build\x64\Release\pycaffe&lt;/code&gt;设置环境变量PythonPath。设置之后打开Python，若import caffe成功则表示编译成功。&lt;/p&gt;

&lt;h1 id=&#34;caffe-mnist-示例&#34;&gt;caffe mnist 示例&lt;/h1&gt;

&lt;p&gt;Windows下很多人用cygwin来模拟一些Linux操作，个人推荐使用&lt;a href=&#34;http://babun.github.io/&#34;&gt;Babun&lt;/a&gt;，一款优雅好用的Windows shell工具。&lt;/p&gt;

&lt;p&gt;按照caffe官网&lt;a href=&#34;http://caffe.berkeleyvision.org/gathered/examples/mnist.html&#34;&gt;mnist文档&lt;/a&gt;一步一步即可。&lt;/p&gt;

&lt;h3 id=&#34;下载数据集&#34;&gt;下载数据集&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;进入babun&lt;/li&gt;
&lt;li&gt;cd到caffe_root&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;./data/mnist/get_mnist.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;转化数据集为lmdb&#34;&gt;转化数据集为lmdb&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;修改&lt;code&gt;./examples/mnist/create_mnist.sh&lt;/code&gt;, 第8行&lt;code&gt;BUILD=build/examples/mnist&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;BUILD=Build/x64/Release&lt;/code&gt;, 第17行和第19行&lt;code&gt;convert_mnist_data.bin&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;convert_mnist_data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同样在Babun下，输入&lt;code&gt;./examples/mnist/create_mnist.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;训练lenet&#34;&gt;训练Lenet&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改&lt;code&gt;./examples/mnist/train_lenet.sh&lt;/code&gt;, 第4行&lt;code&gt;./build/tools/caffe train &amp;ndash;solver=examples/mnist/lenet_solver.prototxt $@ &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; BUILD=Build/x64/Release
 $BUILD/caffe train --solver=examples/mnist/lenet_solver.prototxt $@
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在babun下，输入&lt;code&gt;./examples/mnist/train_lenet.sh&lt;/code&gt;，得到如下图结果，示例mnist成功跑通&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/lenet_win.jpg&#34; alt=&#34;lenet_result&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;fast-rcnn-demo示例&#34;&gt;fast rcnn demo示例&lt;/h1&gt;

&lt;p&gt;上面这些步骤完成后，如果直接进入fastrcnn-root,运行&lt;code&gt;python ./tools/demo.py&lt;/code&gt;（&lt;strong&gt;注意：此时在cmd中运行即可，目前babun自带Python，但是好像不能调用系统自带的python&lt;/strong&gt;）会提示不存在ROIPooling，导致demo运行失败。进入caffe项目发现，roi_pooling_layer.cpp 以及 roi_pooling_layer.cu根本就没有编译。因此将 roi_pooling_layer.cpp 添加进 libcaffe-src 中，将 roi_pooling_layer.cu 添加进 libcaffe-cu 中，再重新编译即可。&lt;/p&gt;

&lt;p&gt;再次运行&lt;code&gt;python ./tools/demo.py&lt;/code&gt;得到结果如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/fastrcnn_demo.jpg&#34; alt=&#34;demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/fastrcnn_demo_pic.png&#34; alt=&#34;demo_pic&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;后续&#34;&gt;后续&lt;/h1&gt;

&lt;p&gt;后续就是在fast rcnn上训练自己的数据了，Linux上已经跑通，Windows上有待测试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>翻墙小结</title>
      <link>blog/%E7%BF%BB%E5%A2%99%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Wed, 31 Aug 2016 19:24:13 +0000</pubDate>
      
      <guid>blog/%E7%BF%BB%E5%A2%99%E5%B0%8F%E7%BB%93/</guid>
      <description>&lt;h1 id=&#34;gfw&#34;&gt;GFW&lt;/h1&gt;

&lt;p&gt;互联网时代，透过你在网络上的痕迹，你看到的，正是你自己。&lt;/p&gt;

&lt;p&gt;每天有无数的信息资讯在互联网上传播，你选择看什么，是你的自由，这些也正是你个人意识的体现。前段时间，正值全球关注的奥运盛会，我关掉通知，不上门户网站，偶尔看下知乎，突然发现，如这般的大事件，只要我不想去关注它，它就好像不曾出现在信息流中一样。&lt;/p&gt;

&lt;p&gt;GFW正是这般的存在，国内的互联网服务相对比较完善，有搜索引擎百度、搜狗、bing，有支付服务支付宝、微信以及银联等，有电商网站淘宝、天猫、京东、亚马逊、当当、一号店、苏宁易购等，有快递服务顺丰、申通、中通等，有外卖服务饿了么、百度外卖等，有团购服务如美团、大众点评等，有社交平台微信、QQ、微博、陌陌、知乎等，有视频网站优酷、a爱奇艺、土豆等，有打车服务滴滴、快的等······似乎一个局域网，就能满足你的生活需求。&lt;/p&gt;

&lt;p&gt;然而，没有意识到的东西，并不代表它不存在。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;突破404&#34;&gt;突破404&lt;/h1&gt;

&lt;p&gt;心里学上有个术语叫做舒适区，近两年不断有呼声，希望人们可以走出舒适区，去更大的世界看看。&lt;/p&gt;

&lt;p&gt;在迈出脚步之前，访问各种404网站，似乎是一种心理上的突破。&lt;/p&gt;

&lt;p&gt;不以各种反动素材为例，仅拿Facebook，Twitter，YouTube，GitHub，Cousera为例，Facebook类似于以前没落的人人，如今你也可以将它类比为QQ空间；Twitter可类比国内的新浪微博。Facebook和Twitter上，全世界各地的人们都可以在上面交流，你可以看到为奥巴马的主页点赞，也可以快速全q球的要闻。YouTube，我最喜欢的谷歌服务之一，无数优质的视频资源，优雅的外观设计，几秒后即可关闭的广告甚至没有广告，这无疑是现代互联网视频资源的朝圣地。GitHub，只要你是程序员，我想没有人不想用这个网站的，不说个人开发者了，世界上的巨头谷歌，Facebook，微软等都在网站贡献出自己的开源项目，简直是程序员的交(fu)友(zhi)天堂。Cousera是MOOC平台，即使相对edX、Udacity来说，Cousera对中国无比友好，但是放在亚马逊服务器上的视频资源，仍然难以打开。&lt;/p&gt;

&lt;p&gt;这些全世界的人都在享用的优质互联网服务，我们交了昂贵的网费，却仍然难以享受。&lt;/p&gt;

&lt;p&gt;我们与肖申克的距离，仅仅相距204（404 - 200 ）公里。&lt;/p&gt;

&lt;h1 id=&#34;xx-net&#34;&gt;XX-net&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/XX-net/XX-Net&#34;&gt;XX-net&lt;/a&gt;是GAE项目的继承和发扬，完善的说明文档和稳定易用的服务，的确是免费用户的不二之选。如果你只需要用用谷歌搜索，看看谷歌学术，瞧瞧YouTube视频，那么XX-net是你突破404的最佳选择。当然，修改Hosts文件更简单（可参看&lt;a href=&#34;http://camelshang.github.io/%E9%81%BF%E5%BC%80%E7%99%BE%E5%BA%A6%E8%BF%8E%E6%9D%A5%E8%B0%B7%E6%AD%8C/&#34;&gt;避开百度迎来谷歌&lt;/a&gt;），但是其服务的稳定相对较差。&lt;/p&gt;

&lt;p&gt;XX-net可在&lt;a href=&#34;https://github.com/XX-net/XX-Net&#34;&gt;主页&lt;/a&gt;下载，墙内的可在&lt;a href=&#34;http://pan.baidu.com/s/1kUAEG1D&#34;&gt;百度云&lt;/a&gt;下载(密码: yfv3)。&lt;/p&gt;

&lt;p&gt;官方使用&lt;a href=&#34;https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8&#34;&gt;说明文档&lt;/a&gt;。稍作修改，如下：&lt;/p&gt;

&lt;h3 id=&#34;安装谷歌浏览器&#34;&gt;安装谷歌浏览器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html&#34;&gt;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://liulanmi.com/&#34;&gt;http://liulanmi.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tech.sina.com.cn/down/&#34;&gt;http://tech.sina.com.cn/down/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://bbs.kafan.cn/forum-214-1.html&#34;&gt;http://bbs.kafan.cn/forum-214-1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装谷歌浏览器插件switchyomega&#34;&gt;安装谷歌浏览器插件SwitchyOmega&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/switchomega.png&#34; alt=&#34;switchomega&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;运行xx-net&#34;&gt;运行XX-net&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;打开start.vbs即可&lt;/li&gt;
&lt;li&gt;首次运行，如果弹出请求网络访问，请允许&lt;/li&gt;
&lt;li&gt;首次运行，搜索IP需要一定时间&lt;/li&gt;
&lt;li&gt;运行后会自动打开127.0.0.1
&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/xxnet.jpg&#34; alt=&#34;xxnet_localhost&#34; /&gt;
###　导入bak文件
&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/switchomega2.jpg&#34; alt=&#34;switchomega&#34; /&gt;
&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/switchomega3.jpg&#34; alt=&#34;switchomega&#34; /&gt;
&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/switchomega4.jpg&#34; alt=&#34;switchomega&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;突破404-1&#34;&gt;突破404&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/xxnet2.jpg&#34; alt=&#34;xxnet_localhost&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;后话&#34;&gt;后话&lt;/h1&gt;

&lt;p&gt;对于国内普通用户来说，几乎只需要谷歌服务，毕竟Facebook上没有多少好友，Twitter上又没有多少粉丝。而&lt;strong&gt;修改Hosts文件以及使用XX-net则是两种既简单又不失稳定的翻墙方法&lt;/strong&gt;，这对于普通用户来说，已经满足了他们绝大部分的需求。&lt;/p&gt;

&lt;p&gt;套用产品经理的话来说，有时候用户并不觉得谷歌搜索相比于百度搜索有多强，但是一旦他们用久了，我想孰优孰劣，自在人心。就像这个光怪陆离的世界，有很多人买了Mac电脑，强行装上Windows系统；有的人则买了PC，拼了命去装黑苹果。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>caffe轻度使用体验</title>
      <link>blog/caffe%E8%BD%BB%E5%BA%A6%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Thu, 05 May 2016 21:39:28 +0000</pubDate>
      
      <guid>blog/caffe%E8%BD%BB%E5%BA%A6%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</guid>
      <description>&lt;h1 id=&#34;简单说明&#34;&gt;简单说明&lt;/h1&gt;

&lt;p&gt;caffe毫无疑问是现在使用比较广泛的深度学习网络框架，每一个学习卷积神经网络的人，应该都不可避免要体验一下caffe的特性和魔力。&lt;/p&gt;

&lt;p&gt;由于第一次在装cuda时，不小心将ubuntu装死，导致在登陆界面无法登陆，输入正确密码后闪一两秒钟然后又回到登陆界面。用谷歌搜索各种解决方法均无效后，索性重装系统，然后记录每一步。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;安装步骤&#34;&gt;安装步骤&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;MATLAB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MATLAB的安装按照官方说明即可，一般没有什么坑。需要注意的是，MATLAB的版本与cuda的版本有一个对应关系，在caffe官网有详细说明，在此不表。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;推荐使用anaconda。安装完毕之后，如果无法忍受conda下载速度慢，可以添加&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/&#34;&gt;清华源&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;conda config --add channels &#39;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&#39;
conda config --set show_channel_urls yes
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;cuda&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前装cuda将系统装死，很有可能是因为一些依赖库没有装好。因此在装cuda之前，最好将&lt;a href=&#34;http://caffe.berkeleyvision.org/install_apt.html&#34;&gt;caffe ubuntu installation&lt;/a&gt;中说明的依赖库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler

  sudo apt-get install --no-install-recommends libboost-all-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全都确认安装成功后，再更新系统内核以及软件包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade -y

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后再安装cuda&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sudo dpkg -i cuda*.deb

  sudo apt-get update &amp;amp;&amp;amp; sudo apt-get dist-upgrade

  sudo apt-get install cuda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启系统后，确认英伟达驱动是否已正确安装。
  这时，还需要将cuda添加到系统路径，修改路径&lt;code&gt;～/.bashrc&lt;/code&gt;，请根据个人软件路径以及软件版本相应添加以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  export PATH=/usr/local/cuda-7.5/bin:$PATH

  export LD_LIBRARY_PATH=/usr/local/cuda-7.5/lib64:$LD_LIBRARY_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后&lt;code&gt;source ~/.bashrc&lt;/code&gt;使得修改结果生效，输入&lt;code&gt;nvcc -V&lt;/code&gt;确认路径添加正确，此时cuda安装完毕。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;caffe
首先进入python文件夹，将Python依赖包全部安装
&lt;code&gt;for req in $(cat requirements.txt); do pip install $req; done&lt;/code&gt;
然后在caffe根目录
&lt;code&gt;cp Makefile.config.example Makefile.config&lt;/code&gt;
打开Makefile.config后，添加MATLAB和Python的路径（如果装了anaconda那就是配置anaconda的路径）。
然后就可以编译测试了&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;make all
make test
make runtest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有错误的话，就可以进行Python接口和MATLAB接口的编译了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  make pycaffe
  make matcaffe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此caffe安装结束。&lt;/p&gt;

&lt;h1 id=&#34;caffe使用&#34;&gt;caffe使用&lt;/h1&gt;

&lt;p&gt;caffe官方的mnist,imagenet等几个例子都写得非常详细，按照文档一步一步来，跑几个demo都是比较简单的。跑完demo后，如何用自己的数据来训练网络呢？&lt;/p&gt;

&lt;p&gt;参考imagenet的实例以及&lt;a href=&#34;http://sites.duke.edu/rachelmemo/2015/04/03/train-and-test-lenet-on-your-own-dataset/&#34;&gt;train-and-test-lenet-on-your-dataset&lt;/a&gt;后，摸清楚了如何训练自己的数据了。&lt;/p&gt;

&lt;p&gt;首先将原始数据准备好，比如我的路径是&lt;code&gt;～/Documents/datasets/mw&lt;/code&gt;，该目录下有两个文件夹&lt;code&gt;pos&lt;/code&gt;和&lt;code&gt;neg&lt;/code&gt;分别存放正负样本图片。caffe的实例中，训练数据都是放在&lt;code&gt;caffe/data&lt;/code&gt;中，因此需要将图片分为test,val以及test（或者简单点只需要分为train和test即可）同时需要在该目录下生成一个train.txt，val.txt以及test.txt（简单相应只需要train.txt和test.txt），txt文件内容，每一行都是相应图片以及标签。因此为了方便完成这个数据预处理工作，我写了一个Python脚本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding:utf-8 -*-
import os
import shutil
import random
import math

LABEL = [1,0]
src_pathbase = &#39;/home/camel/Documents/datasets/mw/&#39;
PATH = [src_pathbase+cate for cate in [&#39;pos&#39;,&#39;neg&#39;]]
# print PATH

des_pathbase = &#39;/home/camel/Documents/caffe/data/mw/&#39;
DPATH = [des_pathbase+cate for cate in [&#39;train&#39;,&#39;val&#39;,&#39;test&#39;]]
# print DPATH

for txt in [&#39;train.txt&#39;,&#39;val.txt&#39;,&#39;test.txt&#39;]:
	open(des_pathbase+txt,&#39;w&#39;).close()
for p in DPATH:
	if os.path.exists(p):
		shutil.rmtree(p)
	os.makedirs(p)


for k in xrange(len(PATH)):
	img_files = os.listdir(PATH[k])
	img_num = len(img_files)
	train_num = int(math.ceil(img_num * 0.9))
	test_num = img_num - train_num
	val_num = int(math.ceil(train_num * 0.1))
	train_num = train_num - val_num
	test_list = sorted(random.sample(xrange(img_num),test_num))
	train_val_list = list(set(xrange(img_num))-set(test_list))
	val_list = sorted(random.sample(train_val_list,val_num))
	train_list = list(set(train_val_list)-set(val_list))
	print img_num,train_num,val_num,test_num
	print train_list,len(train_list)
	print val_list,len(val_list)
	print test_list,len(test_list)

	for n in xrange(img_num):
		fpath = os.path.join(PATH[k],img_files[n])
		print fpath
		if n in train_list:
			print &amp;quot;belongs to train&amp;quot;
			with open(&#39;/home/camel/Documents/caffe/data/mw/train.txt&#39;,&#39;a&#39;) as f:
				f.write(&amp;quot;%s %d&amp;quot; % (img_files[n],LABEL[k]))
				f.write(&#39;\n&#39;)
			shutil.copy(fpath,DPATH[0])
		elif n in val_list:
			print &amp;quot;belongs to val&amp;quot;
			with open(&#39;/home/camel/Documents/caffe/data/mw/val.txt&#39;,&#39;a&#39;) as f:
				f.write(&amp;quot;%s %d&amp;quot; % (img_files[n],LABEL[k]))
				f.write(&#39;\n&#39;)
			shutil.copy(fpath,DPATH[1])
		elif n in test_list:
			print &amp;quot;belongs to test&amp;quot;
			with open(&#39;/home/camel/Documents/caffe/data/mw/test.txt&#39;,&#39;a&#39;) as f:
				f.write(&amp;quot;%s %d&amp;quot; % (img_files[n],LABEL[k]))
				f.write(&#39;\n&#39;)
			shutil.copy(fpath,DPATH[2])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据准备好之后，将imagenet下的create_imagenet.sh拷贝到&lt;code&gt;caffe/examples/mw&lt;/code&gt;下，作一些修改，我的修改如下，可根据自己的目录进行相应调整&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXAMPLE=examples/mw
DATA=data/mw
TRAIN_DATA_ROOT=data/mw/train/
VAL_DATA_ROOT=data/mw/val/

echo &amp;quot;Creating train lmdb...&amp;quot;

GLOG_logtostderr=1 $TOOLS/convert_imageset \
    --resize_height=$RESIZE_HEIGHT \
    --resize_width=$RESIZE_WIDTH \
    --shuffle \
    --gray \
    $TRAIN_DATA_ROOT \
    $DATA/train.txt \
    $EXAMPLE/mw_train_lmdb

echo &amp;quot;Creating val lmdb...&amp;quot;

GLOG_logtostderr=1 $TOOLS/convert_imageset \
    --resize_height=$RESIZE_HEIGHT \
    --resize_width=$RESIZE_WIDTH \
    --shuffle \
    --gray \
    $VAL_DATA_ROOT \
    $DATA/val.txt \
    $EXAMPLE/mw_val_lmdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么运行该脚本后，就会将自己的数据生成caffe可处理的数据格式了。其他的就是将train_test.prototxt进行相应的修改，数据上主要修改source下的目录，对应刚刚生成的文件，比如我的就是&lt;code&gt;source: &amp;quot;examples/mw/mw_train_lmdb&amp;quot;&lt;/code&gt;和&lt;code&gt;source: &amp;quot;examples/mw/mw_val_lmdb&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;至此，将自己的数据应用到caffe上大部分都完成了，剩下的就是根据lenet或者imagenet参考设计修改CNN结构。在此不赘述了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>微信模拟登陆</title>
      <link>blog/%E5%BE%AE%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/</link>
      <pubDate>Sat, 16 Jan 2016 04:27:58 +0000</pubDate>
      
      <guid>blog/%E5%BE%AE%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/</guid>
      <description>&lt;h2 id=&#34;微信公众号&#34;&gt;微信公众号&lt;/h2&gt;

&lt;p&gt;近来开了一个公众号，之前做了一个校园家教、讲座、校车等零碎信息的聚合，主要也是基于python的爬虫。但是由于是免费的个人订阅号用户，开发者模式下的限制还是比较多的，比如开发模式下无法创建菜单就是一个令人无比心痛的限制。而且基于微信的理念，主动推送消息一直也是微信所不欢迎的。但是有了模拟登陆，普通用户也可以主动发送消息给订阅者了，当然，由于微信公众号的明确规定，48小时内该订阅者未主动发送消息给公众号，则该公众号无法主动发送消息给订阅者。这条限制就没有办法了，不过基于模拟登陆，可以做的事还是挺多的，比如监控女朋友的知乎、微博等动态，一有新消息就通过公众号推送给自己；监控自己的公交卡余额，低于某阈值则通过公众号将余额推送给自己，方便自己的出行。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;python爬虫&#34;&gt;python爬虫&lt;/h2&gt;

&lt;p&gt;这次微信公众号的模拟登陆抛弃了urllib和urllib2，而选择了requests，相对于前者，后者的确方便了很多，对于不想纠结其中网络访问过程的人来说，的确遍历了不少。除此之外，就是一些很常规的爬虫技巧，比如伪装成浏览器，通过开发者工具观察真实访问地址以及需要提交的数据等。&lt;/p&gt;

&lt;h2 id=&#34;微信模拟登陆&#34;&gt;微信模拟登陆&lt;/h2&gt;

&lt;p&gt;首先在谷歌上搜索了“微信模拟登陆”的关键字，查到了&lt;a href=&#34;https://github.com/daoluan/WXSender-Python/blob/master/wxsender.py&#34;&gt;wxsender&lt;/a&gt;，没有下载下来运行过，但是从url来看好像和现在的不太一样，毕竟作者很长时间没有更新了，于是就重新写了一下，感谢&lt;a href=&#34;https://github.com/daoluan&#34;&gt;daoluan&lt;/a&gt;的工作。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Talk is cheap, show me the code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;github地址&lt;a href=&#34;https://github.com/camelshang/WechatLogin&#34;&gt;WechatLogin&lt;/a&gt;,全部代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding:utf-8 -*-
&amp;quot;&amp;quot;&amp;quot;
2015-01-16 by Camel
https://github.com/daoluan/WXSender-Python/ is acknowledged

&amp;quot;&amp;quot;&amp;quot;
import requests
import hashlib
import re
import time


class WeiXin:

    def __init__(self):
        # 公众号登陆账号密码
        self.unm = &amp;quot;your name&amp;quot;
        self.pwd = &amp;quot;your password&amp;quot;
        self.token = &#39;&#39;
        self.fakeid = &#39;&#39;
        # 字典存储用户与fakeid的关系
        self.users = {}
        self.msg2user_capable = {}
        # session自动处理cookies
        self.session = requests.Session()

    def login(self):
        &amp;quot;&amp;quot;&amp;quot;登陆&amp;quot;&amp;quot;&amp;quot;
        headers = {
            &amp;quot;Host&amp;quot;: &amp;quot;mp.weixin.qq.com&amp;quot;,
            &amp;quot;Referer&amp;quot;: &amp;quot;https://mp.weixin.qq.com/&amp;quot;,
            &amp;quot;User-Agent&amp;quot;: &amp;quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36&amp;quot;
        }
        data = {
            &amp;quot;username&amp;quot;: self.unm,
            &amp;quot;pwd&amp;quot;: hashlib.md5(self.pwd).hexdigest(),
            &amp;quot;imgcode&amp;quot;: &#39;&#39;,
            &amp;quot;f&amp;quot;: &amp;quot;json&amp;quot;
        }
        url_login = &amp;quot;https://mp.weixin.qq.com/cgi-bin/login&amp;quot;
        r_login = self.session.post(url_login, data=data, headers=headers)
        try:
            self.token = re.findall(&amp;quot;token=(\d*)&amp;quot;, r_login.content)[0]
            print &amp;quot;token &amp;quot;, self.token
            if self.token != &#39;&#39;:
                print &amp;quot;login success and get token!&amp;quot;
                # 登陆之后转入首页，可去掉
                url_index = &amp;quot;https://mp.weixin.qq.com/cgi-bin/home?t=home/index&amp;amp;lang=zh_CN&amp;amp;token=%s&amp;quot; % self.token
                r_index = self.session.get(url_index)
                if r_index.status_code == 200:
                    print &amp;quot;get the index&amp;quot;
                else:
                    print &amp;quot;get index failed&amp;quot;
            else:
                print &amp;quot;login failed&amp;quot;
        except:
            print &amp;quot;get token error&amp;quot;

    def get_fakeid(self):
        &amp;quot;&amp;quot;&amp;quot;得到自己的fakeid&amp;quot;&amp;quot;&amp;quot;
        url_fakeid = &amp;quot;https://mp.weixin.qq.com/cgi-bin/settingpage?t=setting/index&amp;amp;action=index&amp;amp;token=%s&amp;amp;lang=zh_CN&amp;quot; % self.token
        r_fakeid = self.session.get(url_fakeid)
        try:
            self.fakeid = re.findall(&amp;quot;fakeid=(\d{10})&amp;quot;, r_fakeid.content)[0]
            print &amp;quot;get fakeid &amp;quot;, self.fakeid
        except:
            print &amp;quot;get fakeid error&amp;quot;

    def get_users(self):
        &amp;quot;&amp;quot;&amp;quot;微信更改网址，推荐用users_capable
           得到用户昵称和对应fakeid，写入users字典&amp;quot;&amp;quot;&amp;quot;
        url_user = &amp;quot;https://mp.weixin.qq.com/cgi-bin/contactmanage?t=user/index&amp;amp;pageidx=0&amp;amp;type=0&amp;amp;token=%s&amp;amp;lang=zh_CN&amp;quot; % self.token
        r_user = self.session.get(url_user)
        total_users = int(re.findall(&amp;quot;totalCount : &#39;(\d*)&#39;&amp;quot;, r_user.content)[0])
        page_count = int(re.findall(&amp;quot;pageCount : (\d*)&amp;quot;, r_user.content)[0])
        page_size = int(re.findall(&amp;quot;pageSize : (\d*),&amp;quot;, r_user.content)[0])
        user_ids = []
        user_names = []
        for pageidx in xrange(page_count):
            url_userpage = &amp;quot;https://mp.weixin.qq.com/cgi-bin/contactmanage?t=user/index&amp;amp;pageidx=%s&amp;amp;type=0&amp;amp;token=%s&amp;amp;lang=zh_CN&amp;quot; % (
                str(pageidx), self.token)
            r_userid = self.session.get(url_userpage)
            thepage_user = re.findall(&amp;quot;\&amp;quot;id\&amp;quot;:\&amp;quot;(.*?){28}\&amp;quot;&amp;quot;, r_userid.content)
            thepage_username = re.findall(
                &amp;quot;\&amp;quot;nick_name\&amp;quot;:\&amp;quot;(.*?)\&amp;quot;&amp;quot;, r_userid.content)
            user_ids += thepage_user
            user_names += thepage_username
        self.users = dict(zip(user_names, user_ids))
        print &amp;quot;get users done&amp;quot;

    def get_users_capable(self):
        url_msgusers = &amp;quot;https://mp.weixin.qq.com/cgi-bin/message?t=message/list&amp;amp;action=&amp;amp;keyword=&amp;amp;offset=0&amp;amp;count=%d&amp;amp;day=7&amp;amp;filterivrmsg=&amp;amp;token=%s&amp;amp;lang=zh_CN&amp;quot;
        r_msgusers = self.session.get(url_msgusers % (20,self.token))
        total_msg = int(re.findall(r&#39;total_count : (\d*)&#39;, r_msgusers.content)[0])
        r_allmsgusers = self.session.get(url_msgusers % (total_msg,self.token))
        fakeid = re.findall(r&amp;quot;\&amp;quot;fakeid\&amp;quot;:\&amp;quot;(.*?){28}\&amp;quot;&amp;quot;, r_allmsgusers.content)
        nick_name = re.findall(r&amp;quot;\&amp;quot;nick_name\&amp;quot;:\&amp;quot;(.*?)\&amp;quot;&amp;quot;, r_allmsgusers.content)
        date_time = map(int, re.findall(r&amp;quot;\&amp;quot;date_time\&amp;quot;:(\d*)&amp;quot;, r_allmsgusers.content))
        now = time.time()
        less_than_48h = [i for i in date_time if now-i &amp;lt; 172800]
        msg_capable = len(less_than_48h)
        fakeid_capable = list(set(fakeid[:msg_capable]))
        nick_name_capable = list(set(nick_name[:msg_capable]))
        self.msg2user_capable = dict(zip(nick_name_capable, fakeid_capable))
        print &amp;quot;get users_capable done&amp;quot;

    def msg2user(self, msg, touserid):
        &amp;quot;&amp;quot;&amp;quot;发送消息给单个指定用户&amp;quot;&amp;quot;&amp;quot;
        url_msg = &amp;quot;https://mp.weixin.qq.com/cgi-bin/singlesend?t=ajax-response&amp;amp;f=json&amp;amp;token=%s&amp;amp;lang=zh_CN&amp;quot; % self.token
        msg_headers = {
            &amp;quot;Host&amp;quot;: &amp;quot;mp.weixin.qq.com&amp;quot;,
            &amp;quot;Origin&amp;quot;: &amp;quot;https://mp.weixin.qq.com&amp;quot;,
            &amp;quot;Referer&amp;quot;: &amp;quot;https://mp.weixin.qq.com/cgi-bin/singlesendpage?t=message/send&amp;amp;action=index&amp;amp;tofakeid=%s&amp;amp;token=%s&amp;amp;lang=zh_CN&amp;quot; % (touserid, self.token),
            &amp;quot;User-Agent&amp;quot;: &amp;quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36&amp;quot;
        }
        msg_data = {
            &amp;quot;token&amp;quot;: self.token,
            &amp;quot;lang&amp;quot;: &amp;quot;zh_CN&amp;quot;,
            &amp;quot;f&amp;quot;: &amp;quot;json&amp;quot;,
            &amp;quot;ajax&amp;quot;: &amp;quot;1&amp;quot;,
            &amp;quot;random&amp;quot;: &amp;quot;0.4469808244612068&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;1&amp;quot;,
            &amp;quot;content&amp;quot;: msg,
            &amp;quot;tofakeid&amp;quot;: touserid,
            &amp;quot;imgcode&amp;quot;: &#39;&#39;
        }
        r_msg = self.session.post(url_msg, data=msg_data, headers=msg_headers)
        if r_msg.status_code == 200:
            err_msg = re.findall(&amp;quot;\&amp;quot;err_msg\&amp;quot;:\&amp;quot;(.*?)\&amp;quot;&amp;quot;, r_msg.content)[0]
            # 发送成功
            if err_msg == &#39;ok&#39;:
                print &amp;quot;send msg %s to %s done&amp;quot; % (msg,touserid)
            # 微信限制，用户48小时内没有主动发送消息，则公众号无法发送消息给该用户
            elif err_msg == &#39;customer block&#39;:
                print &amp;quot;denied because the user hasn&#39;t send msg to you in the past 48 hours&amp;quot;
            else:
                print &amp;quot;failed,&amp;quot;, err_msg
        else:
            print &amp;quot;send msg to %s failed,and the err_msg %s&amp;quot; % (touserid, r_msg.status_code)

    def msg2users(self, msg):
    	for user in self.msg2user_capable:
    		self.msg2user(msg, self.msg2user_capable[user])

    def send2user(self, msg, touser):
        &amp;quot;&amp;quot;&amp;quot;msg : str
           touser : 用户的昵称&amp;quot;&amp;quot;&amp;quot;
        self.login()
        self.get_fakeid()
        self.get_users_capable()
        if touser in self.msg2user_capable:
            print &amp;quot;user %s exists&amp;quot; % touser
            self.msg2user(msg, self.msg2user_capable[touser])
        else:
            print &amp;quot;user %s not exists&amp;quot; % touser

    def send2users(self, msg):
        self.login()
        self.get_fakeid()
        self.get_users_capable()
        self.msg2users(msg)


wx = WeiXin()
wx.send2user(&#39;test测试&#39;, &#39;Camel&#39;) # &#39;Camel&#39;是我的昵称，请替换成自己的
wx.send2users(&#39;test测试二&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/wx_res.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;微信得到推送消息如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/wx_res_cut_resize.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;后续工作&#34;&gt;后续工作&lt;/h2&gt;

&lt;p&gt;按照前面的设想，后续就是让服务器去不断爬自己需要的数据，然后在设定的情况下通过公众号推送给自己。或许，按照微信的发展理念，以后微信的应用号估计也很难突破主动发送消息给用户的限制，因此作为微信重度用户，个人拿来玩玩儿还是不错的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>避开百度迎来谷歌</title>
      <link>blog/%E9%81%BF%E5%BC%80%E7%99%BE%E5%BA%A6%E8%BF%8E%E6%9D%A5%E8%B0%B7%E6%AD%8C/</link>
      <pubDate>Tue, 12 Jan 2016 18:06:59 +0000</pubDate>
      
      <guid>blog/%E9%81%BF%E5%BC%80%E7%99%BE%E5%BA%A6%E8%BF%8E%E6%9D%A5%E8%B0%B7%E6%AD%8C/</guid>
      <description>

&lt;h2 id=&#34;关于百度&#34;&gt;关于百度&lt;/h2&gt;

&lt;p&gt;百度是一家什么公司，在此就不多加叙述了。仅以鲁迅先生的一句话作结：
&amp;gt; 我向来是不惮以最坏的恶意，来推测百度的，然而我还不料，也不信竟会下劣凶残到这地步。&lt;/p&gt;

&lt;p&gt;百度号称作为第一大中文搜索引擎，这两天因卖血友病贴吧吧主而闹得甚嚣尘上。请移步&lt;a href=&#34;https://www.zhihu.com/question/39322261&#34;&gt;百度贴吧的血友病吧被卖了，原吧主小吧主突然间全部被拿下。如何看待这样的行为？&lt;/a&gt; 以及&lt;a href=&#34;https://www.zhihu.com/question/25043586?rf=27678560&#34;&gt;百度作了哪些恶？&lt;/a&gt;。我不禁想起了百度的由来：
&amp;gt; 众里寻他千百度，暮然回首，那人却在大把捞钱处。&lt;/p&gt;

&lt;p&gt;推荐霍炬的文章&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MjM5MTE4Nzk1NA==&amp;amp;mid=401941606&amp;amp;idx=1&amp;amp;sn=72a6309b2a9c500213de6d0ccd288aea&amp;amp;scene=0&#34;&gt;我是如何坚持10多年站在反百度第一线的&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;避开百度&#34;&gt;避开百度&lt;/h2&gt;

&lt;p&gt;身在天朝，避开百度是一家习惯上的改变问题。提供一下方案。
1. 使用搜索引擎&lt;a href=&#34;http://global.bing.com/?FORM=HPCNEN&amp;amp;setmkt=en-us&amp;amp;setlang=en-us&#34;&gt;bing&lt;/a&gt;。
2. 翻墙用google搜索引擎。
    - 付费
        + 购买国外VPS搭建shadowsocks
        + 购买shadowscoks套餐
    - 免费
        + 代理软件，如赛风，蓝灯等
        + 修改hosts&lt;/p&gt;

&lt;p&gt;在此，仅对免费方案下的修改hosts进行详细说明，因为hosts里的ip相对来说，免费易得，对于翻墙只需要google搜索、facebook设计等用户群来说是最佳的选择。&lt;/p&gt;

&lt;p&gt;个人常用的网站是&lt;a href=&#34;http://serve.netsh.org/pub/ipv4-hosts/&#34;&gt;ipv4 hosts&lt;/a&gt;，校园网用户可访问&lt;a href=&#34;http://serve.netsh.org/pub/ipv4-hosts/&#34;&gt;ipv6 hosts&lt;/a&gt;。选择下图中相应的服务之后&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/hosts.png&#34; alt=&#34;hosts_service&#34; /&gt;点击下方的立即获取，就可以在下方的hosts区域获得相应服务的ip地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xt5lb.com2.z0.glb.clouddn.com/hosts2.png&#34; alt=&#34;hosts&#34; /&gt;将这些ip地址复制到windows下的
&amp;gt; C:/windows/system32/drivers/ect/hosts&lt;/p&gt;

&lt;p&gt;或者linux下的
&amp;gt; /etc/hosts&lt;/p&gt;

&lt;p&gt;的hosts文件中，保存（如出现权限问题，请修改相应权限再复制，或者创建hosts文件，将上面的ip作为文件内容保存，再在相应位置覆盖即可）。&lt;/p&gt;

&lt;p&gt;这时在浏览器访问&lt;a href=&#34;https://www.google.com&#34;&gt;google https://www.google.com&lt;/a&gt;或者&lt;a href=&#34;https://www.facebook.com&#34;&gt;facebook https://www.facebook.com&lt;/a&gt;或者&lt;a href=&#34;https://www.twitter.com&#34;&gt;twitter https://www.twitter.com&lt;/a&gt;即可了。&lt;strong&gt;注意，请用https而非http来访问。&lt;/strong&gt; &lt;strong&gt;注意，请用https而非http来访问。&lt;/strong&gt; &lt;strong&gt;注意，请用https而非http来访问。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果此时访问404，可能是DNS缓存的问题。windows用户按下win+r打开cmd后，输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ipconfig /flushdns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或linux用户打开终端运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/rc.d/init.d/nscd restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行DNS缓存刷新。此时应该可以正确避开百度访问谷歌了。&lt;/p&gt;

&lt;p&gt;其他很多搜索引擎用关键词hosts或者谷歌ip都能得到最新的hosts文件。一般来说，一两个月可能需要重新修改一次，这对于只需要google搜索引擎的用户来说，是一种比较好的选择。关于其原理，可移步&lt;a href=&#34;https://www.zhihu.com/question/19782572&#34;&gt;hosts原理&lt;/a&gt;。理论上修改hosts存在一些安全问题，所以请找靠谱的hosts源，以防别人加入钓鱼IP或者别有用心的个人反向代理。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;使用搜索引擎终究是一个习惯的问题，我相信一个好的搜索引擎是高效工作、愉悦生活的利器，这点上，百度离谷歌隔了了361个360。&lt;/p&gt;

&lt;p&gt;最后作结：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;携程事，准拟系统又误。谷歌曾有人妒。千金可卖贴吧主，滔滔恶行谁诉。君莫舞，君不见，玉环飞燕皆尘土。用户最苦。休去用百度，谷歌正在，缓慢回归路。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>